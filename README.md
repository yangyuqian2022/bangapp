四维纵横笔试题
---

Task1.

测试环境为阿里云2c8g ECS，采用自动生成的数据集，性能测试结果如下:

| 任务      | 扫描数据集大小 | 查询时间(ms) |
| ----------- | ----------- |-------------|
| Task1      | 10,000,000   |   85.25ms   |      
| Task1      | 100,000,000  |   845.78ms  |
| Task1      | 300,000,000  |   2586.83ms |

显然，目前的实现是顺序扫描的，数据集vs查询性能的关系也基本满足线性相关，针对海量数据场景是不友好的.

Task2.
先二叉做查找，定位a扫描的开始和结束位置
* 二叉查找: idx1 <= min(a) 的第一个值，找到就停止，否则就是全表扫描
* 二叉查找: idx2 >= max(a) 的第一个值，找到就停止，否则就是全表扫描

如果idx2 - idx1的查询范围还是接近全表扫描，不能将查询数据降低到10%范围内，就再根据b的范围进一步优化，目前由于b的有序是针对a列来看的，因此必然需要对a列中选中的列做全局扫描，如果a列范围选中效果不佳，就会导致b列也选中很多.

能否按照b列做一个索引？做索引也涉及对全局数据做扫描

```
{ 500,  20 },
{ 1000, 31 }, 
{ 1000, 72 },
{ 1500, 12 },
{ 1500, 34 },
{ 2000, 22 },
{ 2000, 33 },
{ 4000, 20 }
{ 4000, 25 }
```

总找 (a, b) 的排序来做查找，按照例子中的条件，最左侧应该是 (1000, 10) 最右侧应该是 (3000, 50)

因此需要实现一个Row对象的比较函数：
int compare(left, right)
{...}

这样就可以在整个数组中进行二叉查找了：
* row1 == row2 when row1.a == row2.a and row1.b == row2.b
* row1 > row2 when (row1.a > row2.a) || (row1.a >= row2.a && row1.b > row2.b)
* row1 < row2 when (row1.a < row2.a) || (row1.a <>= row2.a && row1.b < row2.b)


条件：a in (1000, 2000, 3000) and b between 10 and 50
可以分多段查找：

(1000, 10)~(1000, 50)

(2000, 10)~(2000, 50)

(3000, 10)~(3000, 50)